/*
 * Parser.jj
 *
 * A Java-- (MiniJava) parser.
 */

options {
	LOOKAHEAD=1;
}

PARSER_BEGIN(Parser)
	import java.io.*;
	import java.io.InputStream;

	public class Parser {
		public static void main(String args[]) throws ParseException, IOException {
			Parser parser;

			InputStream parserStream = (args.length == 0) ? System.in : readInputFile(args[0]);
			parser = new Parser(parserStream);

			SimpleNode root = parser.Program();
			root.dump("");
		}
    
		public static InputStream readInputFile(String inputFile) 
			throws IOException {
				File initialFile = new File(inputFile);
				InputStream targetStream = new FileInputStream(initialFile);
				return targetStream;
			}
	}
PARSER_END(Parser)

/* 
 * Lexer token definitions
 */

/* Whitespace characters */
SKIP :
{
	" " | "\t" | "\n" | "\r" | "\f"
}

/* Comments */
SPECIAL_TOKEN : 
{
	< SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") > |
	< MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" > |
	< DOCS_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" > 
}

/* General reserved keywords and characters */
TOKEN :
{
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< RETURN : "return" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< LENGTH : "length" > |
	< NEW : "new" > | 
	< TRUE : "true" > | 
	< FALSE : "false" > | 
	< THIS : "this" > | 
	< DOT : "." > |
	< COMMA: "," > |
	< NOT : "!" > |
	< SEMICOLON: ";" > |
	< LPARENS : "(" > |
	< RPARENS : ")" > |
	< LSQPARENS : "[" > |
	< RSQPARENS : "]" >  |
	< LBRACKET : "{" > |
	< RBRACKET : "}" > |
	< ASSIGN : "=" > 
}

/* Types */
TOKEN : {
	< TYPE_STRING : "String" > |
	< TYPE_BOOLEAN : "boolean" > | 
	< TYPE_INT : "int" >
}

/* Operators */
TOKEN : {
	< LESSTHAN : "<" > |
	< AND : "&&" > |
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDES : "/" > |
	< ARITHMETIC_OPERATOR : <PLUS> | <MINUS> | <TIMES> | <DIVIDES> >
}

/* Literals */
TOKEN : {
	< INTEGER_LITERAL : ["1"-"9"] (<DIGIT>)* | "0" > |
	< BOOLEAN_LITERAL : "true" | "false" >
}

/* Identifiers */
TOKEN :
{
	< IDENTIFIER : <LETTER> (<LETTER> | <DIGIT>)* > |
	< #DIGIT : [ "0"-"9" ] > | 
	< #LETTER: [ "a"-"z", "A"-"Z", "_" ] >
}

/*
 * Grammar definition
 */

SimpleNode Program() #Start : {}
{
	ClassDecl() <EOF> { return jjtThis; }
}

void ClassDecl() #Class : {Token t;} 
{
	<CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <LBRACKET>
		(VarDecl())*
		(<PUBLIC> (MainDecl() | MethodDecl()))*
	<RBRACKET>
}

void MainDecl() #Main : {}
{
	<STATIC> <VOID> <MAIN>
	<LPARENS> <TYPE_STRING> <LSQPARENS> <RSQPARENS> <IDENTIFIER> <RPARENS> <LBRACKET>
		(LOOKAHEAD(2) VarDecl())*
		(Stmt())*
	<RBRACKET>
}

void MethodDecl() #Method : {Token t;}
{
	Type() t=<IDENTIFIER> {jjtThis.val = t.image;}
	<LPARENS> (Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*)? <RPARENS>
	<LBRACKET>
		(LOOKAHEAD(2) VarDecl())*
		(Stmt())*
		<RETURN> (Expr())? <SEMICOLON>
	<RBRACKET>
}

void Type() #void : {} 
{
	LOOKAHEAD(2)
	<TYPE_INT> (<LSQPARENS> <RSQPARENS>)?
	|
	<TYPE_BOOLEAN> 
	|
	<IDENTIFIER>
}

void VarDecl() #Variable : {Token t;}
{
	Type() t=<IDENTIFIER> {jjtThis.val = t.image;} <SEMICOLON>
}

void Stmt() #void : {}
{
	Block()
	|
	LOOKAHEAD(2)
	AssignStmt()
	|
	LOOKAHEAD(2)
	ExprStmt()
	|
	IfStmt()
	|
	WhileStmt()
}

void Block() #void : {}
{
	<LBRACKET> (Stmt())* <RBRACKET>
}

void AssignStmt() #Assign : {Token t;}
{
	t=<IDENTIFIER> (<LSQPARENS> Expr() <RSQPARENS>)? {jjtThis.val = t.image;} #Lhs 
	<ASSIGN> 
	Expr() #Rhs 
	<SEMICOLON>
}

void ExprStmt() : {}
{
	Expr() <SEMICOLON>
}

void IfStmt() #If : {}
{
	<IF> <LPARENS> Expr() #IfCondition <RPARENS> Stmt() <ELSE> Stmt() #Else
}

void WhileStmt() #While : {}
{
	<WHILE> <LPARENS>
	try {
		Expr() #WhileCondition 
	} catch (ParseException e) {
		error_skipto(LBRACKET);
	}
	<RPARENS> Stmt()
}

void Expr() #void : {}
{
	ExprAnd()
}

void ExprAnd() #void : {}
{
	ExprRelation()
	(
		<AND>
		ExprRelation()
	)*
}

void ExprRelation() #void : {Token t;}
{
	ExprAddSub() 
	(
		<LESSTHAN> ExprAddSub() #LessThan 
	)*
}

void ExprAddSub() #void : {}
{
	ExprMulDiv() 
	(
		<PLUS> ExprMulDiv() #Add
		|
		<MINUS> ExprMulDiv() #Sub
	)*
}

void ExprMulDiv() #void : {}
{
	ExprUnary()
	(
		<TIMES> ExprUnary() #Mul
		|
		<DIVIDES> ExprUnary() #Div
	)*
}

void ExprUnary() #void : {}
{
	(<NOT>)*
	ExprSuffix()
}

void ExprSuffix() #void : {Token t;}
{
	ExprPrefix()
	(
		<LSQPARENS> Expr() <RSQPARENS>
		|
		LOOKAHEAD(2)
		<DOT> 
		(
		<LENGTH>
		|
		t=<IDENTIFIER> {jjtThis.val = t.image;} #MethodCall 
		<LPARENS> (Expr() (<COMMA> Expr())* )? <RPARENS>
		)	
	)*
}

void ExprPrefix() #void : {Token t;}
{
	t=<INTEGER_LITERAL> {jjtThis.val = t.image;} #Term
	|
	t=<TRUE> {jjtThis.val = t.image;} #Term
	| 
	t=<FALSE> {jjtThis.val = t.image;} #Term
	| 
	t=<IDENTIFIER> {jjtThis.val = t.image;} #Term
	| 
	t=<THIS> {jjtThis.val = t.image;} #Term
	|
	<LPARENS> Expr() <RPARENS> 
	|
	LOOKAHEAD(2)
	<NEW> (
		t=<TYPE_INT> {jjtThis.val = t.image;} #New <LSQPARENS> (Expr())? <RSQPARENS> 
		|
		t=<IDENTIFIER> {jjtThis.val = t.image;} #New <LPARENS> <RPARENS>
	)
}

/*
 * Errors
 */

JAVACODE
void error_skipto(int kind) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been "while").
}
