/*
 * Parser.jj
 *
 * A Java-- (MiniJava) parser.
 */

options {
	LOOKAHEAD=1;
  // DEBUG_PARSER=true;
}

PARSER_BEGIN(Parser)
	import java.io.*;
	import java.io.InputStream;

	public class Parser {
		public static void main(String args[]) throws ParseException, IOException {
			Parser parser;

			InputStream parserStream = (args.length == 0) ? System.in : readInputFile(args[0]);
			parser = new Parser(parserStream);

			SimpleNode root = parser.Program();
      root.dump("");
		}
    
		public static InputStream readInputFile(String inputFile) 
			throws IOException {
				File initialFile = new File(inputFile);
				InputStream targetStream = new FileInputStream(initialFile);
				return targetStream;
			}
	}
PARSER_END(Parser)

/* 
 * Lexer token definitions
 */

/* Whitespace characters */
SKIP :
{
	" " | "\t" | "\n" | "\r" | "\f"
}

/* Comments */
SPECIAL_TOKEN : 
{
	< SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") > |
	< MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" > |
	< DOCS_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" > 
}

/* General reserved keywords and characters */
TOKEN :
{
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< RETURN : "return" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< LENGTH : "length" > |
	< NEW : "new" > | 
	< TRUE : "true" > | 
	< FALSE : "false" > | 
	< THIS : "this" > | 
	< DOT : "." > |
	< NOT : "!" > |
	< SEMICOLON: ";" > |
	< PARENS_OPEN : "(" > |
	< PARENS_CLOSE : ")" > |
	< SQBRACKET_OPEN : "[" > |
	< SQBRACKET_CLOSE : "]" >  |
	< BRACKET_OPEN : "{" > |
	< BRACKET_CLOSE : "}" >
}

/* Types */
TOKEN : {
	< TYPE_STRING : "String" > |
	< TYPE_BOOLEAN : "boolean" > | 
	< TYPE_INT : "int" >
}

/* Operators */
TOKEN : {
	< LT : "<" > |
	< AND : "&&" > |
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDES : "/" > |
	< ARITHMETIC_OPERATOR : <PLUS> | <MINUS> | <TIMES> | <DIVIDES> >
}

/* Literals */
TOKEN : {
	< INTEGER_LITERAL : ["1"-"9"] (<DIGIT>)* | "0" > |
	< BOOLEAN_LITERAL : "true" | "false" >
}

/* Identifiers */
TOKEN :
{
	< IDENTIFIER : <LETTER> (<LETTER> | <DIGIT>)* > |
	< #DIGIT : [ "0"-"9" ] > | 
	< #LETTER: [ "a"-"z", "A"-"Z", "_" ] >
}

/*
 * Grammar definition
 */

void Program() : {}
{
	ClassDecl() <EOF>
}

void ClassDecl() : {} 
{
	<CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <BRACKET_OPEN>
		(VarDecl())*
		(
			<PUBLIC>
			(MainDecl() | MethodDecl())
		)*
	<BRACKET_CLOSE>
}

void MainDecl() : {}
{
	<STATIC> <VOID> <MAIN>
	<PARENS_OPEN> <TYPE_STRING> <SQBRACKET_OPEN> <SQBRACKET_CLOSE> <IDENTIFIER> <PARENS_CLOSE> <BRACKET_OPEN>
		(VarDecl())*
		(Stmt())*
	<BRACKET_CLOSE>
}

void MethodDecl() : {}
{
	Type() <IDENTIFIER> 
	<PARENS_OPEN> (Type() <IDENTIFIER> ("," Type() <IDENTIFIER>)*)? <PARENS_CLOSE>
	"{"
		(VarDecl())*
		(Stmt())*
		<RETURN> (Expr())? <SEMICOLON>
	"}"
}

void Type() : {} 
{
	<TYPE_BOOLEAN> |
	<TYPE_INT>  (<SQBRACKET_OPEN> <SQBRACKET_CLOSE>)?
}

void VarDecl() : {}
{
	Type() <IDENTIFIER> <SEMICOLON>
}

void Stmt() : {}
{
	"{" (Stmt())* "}"
	|
	IfStmt()
	|
	WhileStmt()
	|
	(LOOKAHEAD(2) <IDENTIFIER> ("[" Expr() "]")? "=")? Expr() <SEMICOLON>
}

void IfStmt() : {}
{
	<IF> <PARENS_OPEN> Expr() <PARENS_CLOSE> Stmt() <ELSE> Stmt()
}

void WhileStmt() : {}
{
	<WHILE> <PARENS_OPEN> 
	try {
		Expr() 
	} catch (ParseException e) {
		error_skipto(PARENS_CLOSE);
	}
	<PARENS_CLOSE> Stmt()
}

void Expr() : {}
{
	ExprLhs() ExprRhs()
}

void ExprLhs() : {}
{
	<INTEGER_LITERAL> |
	<TRUE> | 
	<FALSE> | 
	<IDENTIFIER> | 
	<THIS> | 
	ExprNew() |
 	<NOT> Expr() | 
	<PARENS_OPEN> Expr() <PARENS_CLOSE>
}

void ExprRhs() : {}
{
	(LOOKAHEAD(2)
	(
		( "&&" | "<" | <PLUS> | <MINUS> | <TIMES> | <DIVIDES>) Expr() ExprRhs()
	|
		("[" Expr() "]")
	|
		(".length")
	|
		(<DOT> <IDENTIFIER> <PARENS_OPEN>  (Expr() ( "," Expr() )* )? <PARENS_CLOSE> )
	))?
}

void ExprNew() : {}
{
	<NEW>
	(
		(<TYPE_INT> <SQBRACKET_OPEN> Expr() <SQBRACKET_CLOSE>)
	|
		(<IDENTIFIER>  <PARENS_OPEN> <PARENS_CLOSE>)
	)
}

/*
 * Errors
 */

JAVACODE
void error_skipto(int kind) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been "while").
}
